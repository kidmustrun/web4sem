# Виды токенов
### Simple Web Token (SWT) 
Это самый простой формат, представляющий собой набор произвольных пар имя/значение в формате кодирования HTML-форм. Стандарт определяет несколько зарезервированных имен: Issuer, Audience, ExpiresOn и HMACSHA256. Токен подписывается с помощью симметричного ключа, таким образом оба IP- и SP-приложения должны иметь этот ключ для возможности создания/проверки токена.

***Пример SWT токена после декодирования***

    Issuer=http://auth.myservice.com&
    Audience=http://myservice.com&
    ExpiresOn=1435937883&
    UserName=Irina Gromova&
    UserRole=Admin&
    HMACSHA256=KOUQRPSpy64rvT2KnYyQKtFFXUIggnesSpE7ADA4o9w

### JSON Web Token (JWT) 
Это JSON объект, который определен в открытом стандарте RFC 7519. Он считается одним из безопасных способов передачи информации между двумя участниками. Для его создания необходимо определить заголовок (*header*) с общей информацией по токену, полезные данные (*payload*), такие как id пользователя, его роль и т.д. и подписи (*signature*). Алгоритм base64url кодирует *header* и *payload*. Далее необходимо соединить закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в *header* на основе нашего секретного ключа. 

***Пример подписанного JWT токена (после декодирования 1 и 2 блоков)***

    header:
    { "alg": "HS256", "typ": "JWT"}
    payload:
    { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
    signature:
    -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM // закодирована с помощью секретного ключа

***Пример закодированного JWT-токена***

    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM

Всякий раз, когда пользователь хочет получить доступ к защищенному маршруту или ресурсу, пользователь должен отправлять JWT в заголовке авторизации. Содержимое заголовка должно выглядеть следующим образом:

    Authorization: Bearer <token>

### Security Assertion Markup Language (SAML) 
Определяет токены (*SAML assertions*) в XML-формате, включающем информацию об эмитенте, о субъекте, необходимые условия для проверки токена, набор дополнительных утверждений (*statements*) о пользователе. Подпись SAML-токенов осуществляется при помощи ассиметричной криптографии. Кроме того, в отличие от предыдущих форматов, SAML-токены содержат механизм для подтверждения владения токеном, что позволяет предотвратить перехват токенов через man-in-the-middle-атаки при использовании незащищенных соединений.

### Практическое задание (используя JWT-токен)
Имеем следующие данные.
***Header:*** 

    {
    "alg": "HS256", // алгоритм хэширования (HS256), для его вычисления секретный ключ 
    "typ": "JWT" // тип токена
    }
***Payload:***

    {
      "user_name": "Irina Gromova", // Имя пользователя
      "user_id": "13012002", // ID пользователя
      "user_device_id": "D0-94-66-F6-14-7C", // ID устройства пользователя
      "user_role": "ROLE_USER", // Роль пользователя
      "iss": "auth.myservice.com", // Кто выдал токен
      "aud": "myservice.com", // Для кого предназначен токен
      "iat": 1475874457, // Время в которое выдан токен в отсчете с 1970-01-01
      "exp": 1475878357 // Время жизни токена с момента времени, в которое он выдан (то есть 1475878357 - 1475874457 = 3900 сек, 3900 сек / 60 сек = 65 мин 
    }

***Подпись вычисляется с использованием следующего псевдо-кода:***

    const SECRET_KEY = 'mostSecretPasswordInTheWorld' // задаем секретный ключ
    const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload) // создаем неподписанный токен
    const signature = HMAC-SHA256(unsignedToken, SECRET_KEY) // хэшируем подпись
***Соединяем токен:***

    const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature) // составляем подписанный токен

***На выходе получаем закодированный токен:***

    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJJcmluYSBHcm9tb3ZhIiwidXNlcl9pZCI6IjEzMDEyMDAyIiwidXNlcl9kZXZpY2VfaWQiOiJEMC05NC02Ni1GNi0xNC03QyIsInVzZXJfcm9sZSI6IlJPTEVfVVNFUiIsImlzcyI6ImF1dGgubXlzZXJ2aWNlLmNvbSIsImF1ZCI6Im15c2VydmljZS5jb20iLCJpYXQiOjE0NzU4NzQ0NTcsImV4cCI6MTQ3NTg3ODM1N30.gurMFyeNIzT_L5s2fjLlpa8jT24H_SCD9em_JqGBKVY

В итоге процесс выглядит следующим образом. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить алгоритм подписывания. При получении запроса с токеном сервер разделяет токен на части, распаковывает заголовок и находит алгоритм подписи. Подпись, как мы помним, представляет из себя шифрованный по секретному ключу хэш от первых двух частей. Поэтому сервер вычисляет контрольную подпись от первых двух частей токена и сравнивает её с полученной в токене. Если подписи совпадают, значит токен валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя JWT, приложение добавляет доверительный слой (a layer of trust) между собой и пользователем.
